// MCM(newman) p.354, p. 437
/*
1. Choose a seed spin at random from the lattice.
2. Look in turn at each of the neighbours of that spin. If they are pointing in the same direction as the seed spin, add them to the cluster with probability P_add = 1-e^(-2*beta*J)
3. For each spin that was added in step 2, examine each of its neighbours to find the ones which are pointing in the same direction, and same procedure of step 2. This step is repeated as many times as necessary until no spin left in cluster whose neighbours have not been considered. 
4. Flip the cluster.
*/

/* padd = 1 - exp(-2*beta*J)
   s[] = lattixe of spins with helical boundary conditions
   L = constant edge length of lattice */

#define N(L*L)
#define XNN 1
#define YNN L

int s[N]; double padd;

void step()
{
	int i;
	int sp;
	int oldspin, newspin;
	int current, nn;
	int stack[N];

/* Choose the seed spin for the cluster, put it on the stack, and flip it */

	i = N*drandom();
	stack[0]=i;
	sp=1;
	oldspin=s[i];
	newspin=-s[i];
	s[i]=newspin;

	while(sp){  /* pull a site off the stack */
		current = stack[--sp];
		    /* check the neighbours */
		if ((nn=current + XNN>=N) nn-=N;
		if (s[nn]==oldspin)
			if (drandom()<padd){
				stack[sp++]=nn;
				s[nn]=newspin;
			}
		if((nn=current - XNN)<0) nn+=N;
		if(s[nn]==oldspin)
			if (drandom()<padd){
				stack[sp++]=nn;
				s[nn]=newspin;
			}
		if ((nn=current+YNN)>=N) nn -=N;
		if (s[nn]=oldspin) 
			if (drandom()<padd){
				stack[sp++]=nn;
				s[nn]=newspin;
			}
		if((nn=current-YNN)<0) nn+=N;
		if(s[nn]==oldspin)
			if(drandom()<padd){
				stack[sp++]=nn;
				s[nn]=newspin;
			}
	}
}

//This is made of C, so drandom() is just double random function.		
